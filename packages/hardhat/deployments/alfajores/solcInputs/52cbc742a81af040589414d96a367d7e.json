{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/SneakerMarketPlace.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract SneakerMarketplace {\n    using Counters for Counters.Counter;\n    Counters.Counter private _sneakerIds;\n    Counters.Counter private _swapIds;\n\n    address payable owner;\n\n    struct Sneaker {\n        uint256 id;\n        address owner;\n        string name;\n        string imageUrl;\n        string color;\n        string size;\n        bool listed;\n    }\n\n    struct SwapRequest {\n        uint256 id;\n        address requester;\n        address owner;\n        uint256 mySneakerId;\n        uint256 theirSneakerId;\n        bool approved;\n    }\n\n    mapping(uint256 => Sneaker) public sneakers;\n    mapping(uint256 => SwapRequest) public swapRequests;\n    uint256[] public allSwapRequestIds;\n\n    event SneakerListed(uint256 indexed sneakerId, address indexed owner, string name, string imageUrl, string color, string size);\n    event SwapRequested(uint256 indexed requestId, address indexed requester, address indexed owner, uint256 mySneakerId, uint256 theirSneakerId);\n    event SwapApproved(uint256 indexed requestId);\n    event SneakerTransferred(uint256 indexed sneakerId, address indexed from, address indexed to);\n\n    constructor() {\n        owner = payable(msg.sender);\n    }\n\n    function createSneaker(string memory name, string memory imageUrl, string memory color, string memory size) public {\n        _sneakerIds.increment();\n        uint256 newSneakerId = _sneakerIds.current();\n        sneakers[newSneakerId] = Sneaker(newSneakerId, msg.sender, name, imageUrl, color, size, false);\n        emit SneakerListed(newSneakerId, msg.sender, name, imageUrl, color, size);\n    }\n\n    function listSneaker(uint256 sneakerId) public {\n        require(sneakers[sneakerId].owner == msg.sender, \"Only the owner can list the sneaker\");\n        require(!sneakers[sneakerId].listed, \"Sneaker is already listed\");\n        sneakers[sneakerId].listed = true;\n    }\n\n//    temporarily disabling this feature\n\n    // function requestSwap(uint256 mySneakerId, address otherUser, uint256 theirSneakerId) public {\n    //     require(msg.sender != otherUser, \"Cannot swap with yourself\");\n    //     require(sneakers[mySneakerId].owner == msg.sender, \"You do not own the selected sneaker\");\n    //     require(sneakers[theirSneakerId].owner == otherUser, \"The other user does not own the selected sneaker\");\n    //     require(sneakers[mySneakerId].listed, \"Sneaker must be listed to be requested for a swap\");\n\n    //     _swapIds.increment();\n    //     uint256 newSwapId = _swapIds.current();\n    //     swapRequests[newSwapId] = SwapRequest(newSwapId, msg.sender, otherUser, mySneakerId, theirSneakerId, false);\n    //     allSwapRequestIds.push(newSwapId);\n    //     emit SwapRequested(newSwapId, msg.sender, otherUser, mySneakerId, theirSneakerId);\n    // }\n\n    // function approveSwap(uint256 requestId) public {\n    //     uint256 mySneakerId = swapRequests[requestId].mySneakerId;\n    //     uint256 theirSneakerId = swapRequests[requestId].theirSneakerId;\n\n    //     require(sneakers[theirSneakerId].owner == msg.sender, \"Only the owner can approve the swap\");\n    //     require(!swapRequests[requestId].approved, \"Swap request has already been approved\");\n\n    //     // Swap the ownership of the sneakers directly\n    //     sneakers[mySneakerId].owner = swapRequests[requestId].owner;\n    //     sneakers[theirSneakerId].owner = swapRequests[requestId].requester;\n\n    //     swapRequests[requestId].approved = true;\n    //     sneakers[mySneakerId].listed = false;\n    //     sneakers[theirSneakerId].listed = false;\n\n    //     emit SwapApproved(requestId);\n    //     emit SneakerTransferred(mySneakerId, msg.sender, sneakers[mySneakerId].owner);\n    //     emit SneakerTransferred(theirSneakerId, sneakers[theirSneakerId].owner, msg.sender);\n    // }\n\n\n    function swapSneaker (uint256 mySneakerId, address otherUser, uint256 theirSneakerId) public {\n        require(msg.sender != otherUser, \"Cannot swap with yourself\");\n        require(sneakers[mySneakerId].owner == msg.sender, \"You do not own the selected sneaker\");\n        require(sneakers[theirSneakerId].owner == otherUser, \"The other user does not own the selected sneaker\");\n        require(sneakers[mySneakerId].listed, \"Sneaker must be listed to be requested for a swap\");\n\n        // Swap the ownership of the sneakers directly\n        sneakers[mySneakerId].owner = otherUser;\n        sneakers[theirSneakerId].owner = msg.sender;\n\n        sneakers[mySneakerId].listed = false;\n        sneakers[theirSneakerId].listed = false;\n\n        emit SneakerTransferred(mySneakerId, msg.sender, sneakers[mySneakerId].owner);\n        emit SneakerTransferred(theirSneakerId, sneakers[theirSneakerId].owner, msg.sender);\n    }\n\n\n    /**\n        * @dev Get a list of sneakers owned by the caller.\n     * @return An array of Sneaker structs representing the user's sneakers.\n     */\n    function getMySneakers() public view returns (Sneaker[] memory) {\n        uint totalSneakers = _sneakerIds.current();\n        uint sneakerCount = 0;\n        uint currentIndex = 0;\n\n        for (uint i = 0; i < totalSneakers; i++) {\n            if (sneakers[i + 1].owner == msg.sender) {\n                sneakerCount += 1;\n            }\n        }\n\n        Sneaker[] memory mySneakers = new Sneaker[](sneakerCount);\n        for (uint i = 0; i < totalSneakers; i++) {\n            if (sneakers[i + 1].owner == msg.sender) {\n                uint currentId = i + 1;\n                Sneaker storage currentSneaker = sneakers[currentId];\n                mySneakers[currentIndex] = currentSneaker;\n                currentIndex += 1;\n            }\n        }\n\n        return mySneakers;\n    }\n\n    function getSwapRequestLength() public view returns (uint) {\n        return allSwapRequestIds.length;\n    }\n\n    function getAllSwapRequests() public view returns (SwapRequest[] memory) {\n        uint totalRequests = allSwapRequestIds.length;\n        SwapRequest[] memory allRequests = new SwapRequest[](totalRequests);\n\n        for (uint i = 0; i < totalRequests; i++) {\n            uint requestId = allSwapRequestIds[i];\n            allRequests[i] = swapRequests[requestId];\n        }\n\n        return allRequests;\n    }\n\n    function getMySwapRequests() public view returns (SwapRequest[] memory) {\n        uint totalRequests = allSwapRequestIds.length;\n        uint requestCount = 0;\n        uint currentIndex = 0;\n\n        for (uint i = 0; i < totalRequests; i++) {\n            uint requestId = allSwapRequestIds[i];\n            if (swapRequests[requestId].requester == msg.sender || swapRequests[requestId].owner == msg.sender) {\n                requestCount += 1;\n            }\n        }\n\n        SwapRequest[] memory myRequests = new SwapRequest[](requestCount);\n        for (uint i = 0; i < totalRequests; i++) {\n            uint requestId = allSwapRequestIds[i];\n            if (swapRequests[requestId].requester == msg.sender || swapRequests[requestId].owner == msg.sender) {\n                myRequests[currentIndex] = swapRequests[requestId];\n                currentIndex += 1;\n            }\n        }\n\n        return myRequests;\n    }\n\n    /**\n    * @dev Get a list of all sneakers currently listed in the marketplace.\n     * @return An array of Sneaker structs representing the listed sneakers.\n     */\n    function getListedSneakers() public view returns (Sneaker[] memory) {\n        uint totalSneakers = _sneakerIds.current();\n        uint listedSneakerCount = 0;\n        uint currentIndex = 0;\n\n        for (uint i = 0; i < totalSneakers; i++) {\n            if (sneakers[i + 1].listed) {\n                listedSneakerCount += 1;\n            }\n        }\n\n        Sneaker[] memory listedSneakers = new Sneaker[](listedSneakerCount);\n        for (uint i = 0; i < totalSneakers; i++) {\n            if (sneakers[i + 1].listed) {\n                uint currentId = i + 1;\n                Sneaker storage currentSneaker = sneakers[currentId];\n                listedSneakers[currentIndex] = currentSneaker;\n                currentIndex += 1;\n            }\n        }\n\n        return listedSneakers;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}